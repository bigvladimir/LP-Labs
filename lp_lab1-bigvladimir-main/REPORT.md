# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Харченко В.М.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

В императивных языках нам нужно полностью описать как нужно получить результат. Декларативный язык Prolog же отличается от императивных языков тем, что в нем описывается результат который мы хотим получить, а программа сама подбирает действия для получения результата.

Списки Prolog похожи на связные списки в обычных языках программирования, только в Prolog нет явных указателей. Списки разделяются на голову и хвост.

Задание 1.1: Предикат обработки списка
======================================

%Удаление трех последних элементов

delete(\[\_,\_,\_\],\[\]).

delete(\[X|Y\], \[X|Z\]) :- delete(Y,Z).

Пример использования:

delete(\[a,b,c,d,e,f\],X).

**X** = \[a, b, c\]

**false**

Т.к. требуется удалить последние 3 элемента списка, то подразумевается,
что список состоит из 3 и более элементов. Реализован рекурсивный
предикат, конец рекурсии – когда в списке 3 элемента. Первый аргумент –
начальный список, второй – конечный. Делаем рекурсию для хвостов
начального и конечного списков, отделяя голову.

Через стандартные предикаты:

remove\_3(L, X) :- append(X,A,L), lenght(A,3).

Задание 1.2: Предикат обработки числового списка
================================================

%Проверка упорядоченности элементов по возрастанию

sequence(\[\_\]).

sequence(\[X,Y|Z\]) :- X&lt;Y, sequence(\[Y|Z\]).

Пример использования:

sequence(\[1,2,3,4\]).

**true**

**false**

На вход рекурсивному предикату подается список. Конец рекурсии – 1
элемент в списке. Делаем проверку на соблюдения условия 1-ый элемент
списка &lt; 2-ого и вызываем рекурсию для списка без 1-ого элемента.

Через стандартные предикаты:

sequence1(\[X,Y|Z\]) :- not(lenght(Z,0)), X&lt;Y, sequence(\[Y|Z\]).

Задание 2: Реляционное представление данных
===========================================

Реляционное представление данных обычно очень громоздкое, что путает
читателя, но программа, вычисляющая какие-то значения по таблице
позволяет сэкономить время, тк подсчеты для определенной задачи
одинаковы.

Для нахождения среднего балла по определенному предмету необходим список
баллов (обеспечивает предикат findall), подсчет длины(количества) нашего
списка (обеспечивает length), и сумма всех элементов списка
(обеспечивает sum), далее выводим средний балл(сумма/количество).

?- findall(X,grade(\_,\_,'Логическое программирование',X),C), lenght(C,N), sum(C,S), write(S/N),nl.

Для нахождения всех не сдавших экзамен из определенной группы считаем
длину списка, состоящего из ‘2’.

?- findall(2,grade(101,\_,\_,2),C), lenght(C,N), write(N),nl.

Для нахождения всех не сдавших экзамен по определенному предмету считаем
длину списка, состоящего из ‘2’.

?- findall(2,grade(\_,\_,'Логическое программирование',2),C), lenght(C,N), write(N),nl.

Выводы
=====

С помощью встроенных предикатов Prolog, если привыкнуть, работать с таблицами легче, чем в традиционных языках,
где приходится проверять множество условий. Сам код программы гораздо компактнее. А написание стандартных простых предикатов было полезным для отработки базовой теории.