#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Харченко В.М.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Поиск в пространстве состояний – группа математических методов, предназначенных для решения задач искусственного интеллекта. То есть используется для решения задач с большим количеством переборов вариантов. Происходит поиск нужного состояния/конфигурации по условию задачи. Это может быть сборка кубика-рубика определенным образом, лабиринт с потаёнными комнатами, где ходит мышь и ищет кусочек сыра, поиск кратчайшего пути от станции до станции в метро и другие. Часто такие задачи можно задать в виде графа, а их построение очень удобно реализовывать на языке Prolog.

## Задание

Вариант 6. Переместить в лунке из 8 дырок 4 черных шарика из начала в конец и 3 белых шарика из конца в начало.

## Принцип решения

Было реализовано 3 вида поиска: в глубину, в ширину, в глубину с итеративным погружением для нахождения кратчайшего пути.

Во всех трёх случаях использовался предикат move(), определяющий движение наших шаров.

move(A,C) :-

    my_append(X,["_","w"|Y],A), my_append(X,["w","_"|Y],C);

    my_append(X,["b","_"|Y],A), my_append(X,["_","b"|Y],C);

    my_append(X,["_","b","w"|Y],A), my_append(X,["w","b","_"|Y],C);

    my_append(X,["b","w","_"|Y],A), my_append(X,["_","w","b"|Y],C).

Так как все поиски реализованы через рекурсию, то каждый раз вызвался предикат дальнейшего хода prolong(), который не содержит в себе member() – проверки “не заходим ли мы в одну и ту же точку второй раз подряд”, потому что по условию движения шаров(черные – только вправо, белые – только влево), они никак не могли возвращаться на одну и ту же позицию.

prolong([A|P],[C,A|P]) :- move(A,C).

Поиск в глубину:

solve_g(A,B,H) :- path_g([A],B,L), my_reverse(L,H).

path_g([B|P],B,[B|P]).

path_g(A,B,H) :- prolong(A,C), path_g(C,B,H).

Поиск в ширину (предикат findall() используется для нахождения всех возможных вариантов на одном и том же уровне дерева вывода, в результате чего находится кратчайший путь, но в данной задаче оба ответа одинаковой длины, поэтому наглядно этого не видно):

solve_sh(A,B,G):- path_sh([[A]],B,L), my_reverse(L,G).

path_sh([[B|P]|_],B,[B|P]).

path_sh([A|P],B,G) :- findall(P1,prolong(A,P1),L), my_append(P,L,C), !, path_sh(C,B,G).

path_sh([_|P],B,G) :- path_sh(P,B,G).

Поиск в глубину с итеративным погружением для нахождения кратчайшего пути (так как мы искали кратчайший путь, то данный поиск уходит в бесконечность из-за перебора всех целых чисел)

solve_it(S,F,P) :- search_id(S,F,K), my_reverse(K,P).

search_id(S,F,P) :- my_integer(Level), search_id(S,F,P,Level).

my_integer(1).

my_integer(M) :- my_integer(N), M is N+1.

search_id(S,F,P,DL) :- path_g([S],F,P,DL).

path_g([B|P],B,[B|P],0).

path_g(A,B,H,N) :- N > 0, prolong(A,C), N1 is N-1, path_g(C,B,H,N1).

## Результаты

Во всех поисках был получен данный ответ (поиск в глубину с итеративным погружением для нахождения кратчайшего пути уходил в бесконечность). Длина пути обоих ответов равно 20.

X = [["b", "b", "b", "b", "_", "w", "w", "w"], ["b", "b", "b", "b", "w", "_", "w", "w"], ["b", "b", "b", "_", "w", "b", "w", "w"], ["b", "b", "_", "b", "w", "b", "w", "w"], ["b", "b", "w", "b", "_", "b", "w", "w"], ["b", "b", "w", "b", "w", "b", "_", "w"], ["b", "b", "w", "b", "w", "b", "w", "_"], ["b", "b", "w", "b", "w", "_", "w", "b"], ["b", "b", "w", "_", "w", "b", "w", "b"], ["b", "_", "w", "b", "w", "b", "w", "b"], ["_", "b", "w", "b", "w", "b", "w", "b"], ["w", "b", "_", "b", "w", "b", "w", "b"], ["w", "b", "w", "b", "_", "b", "w", "b"], ["w", "b", "w", "b", "w", "b", "_", "b"], ["w", "b", "w", "b", "w", "_", "b", "b"], ["w", "b", "w", "_", "w", "b", "b", "b"], ["w", "_", "w", "b", "w", "b", "b", "b"], ["w", "w", "_", "b", "w", "b", "b", "b"], ["w", "w", "w", "b", "_", "b", "b", "b"], ["w", "w", "w", "_", "b", "b", "b", "b"]]

X = [["b", "b", "b", "b", "_", "w", "w", "w"], ["b", "b", "b", "_", "b", "w", "w", "w"], ["b", "b", "b", "w", "b", "_", "w", "w"], ["b", "b", "b", "w", "b", "w", "_", "w"], ["b", "b", "b", "w", "_", "w", "b", "w"], ["b", "b", "_", "w", "b", "w", "b", "w"], ["b", "_", "b", "w", "b", "w", "b", "w"], ["b", "w", "b", "_", "b", "w", "b", "w"], ["b", "w", "b", "w", "b", "_", "b", "w"], ["b", "w", "b", "w", "b", "w", "b", "_"], ["b", "w", "b", "w", "b", "w", "_", "b"], ["b", "w", "b", "w", "_", "w", "b", "b"], ["b", "w", "_", "w", "b", "w", "b", "b"], ["_", "w", "b", "w", "b", "w", "b", "b"], ["w", "_", "b", "w", "b", "w", "b", "b"], ["w", "w", "b", "_", "b", "w", "b", "b"], ["w", "w", "b", "w", "b", "_", "b", "b"], ["w", "w", "b", "w", "_", "b", "b", "b"], ["w", "w", "_", "w", "b", "b", "b", "b"], ["w", "w", "w", "_", "b", "b", "b", "b"]]

False

Время выполнения:

1)Поиск в глубину: 0.002 seconds(первый ответ) + 0.001 seconds(второй ответ)

2)Поиск в ширину: 0.005 seconds(первый ответ) + 0.000 seconds(второй ответ)

3)Поиск в глубину с итеративным погружением для нахождения кратчайшего пути уходил в бесконечность: 0.028 seconds(первый ответ) + 0.001 seconds(второй ответ)

## Выводы

В зависимости от особенностей постановки задачи и доступных ресурсов, выгодно выбирать разные алгоритмы поиска. Так, алгоритм в глубину не будет находить первым ответом кратчайший путь, как это делает поиск в ширину, но будет менее затратным по памяти. Поиск в глубину с итеративным погружением для нахождения кратчайшего пути – некий алгоритм, который берет положительные стороны реализации из предыдущих двух, но также имеет свои отрицательные стороны с уходом в бесконечность, что можно решить с помощью отсечения, но тогда, в случае нескольких ответов в задаче, мы получим лишь один.