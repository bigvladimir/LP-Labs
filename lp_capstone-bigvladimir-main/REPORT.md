# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: <Харченко Владимир Максимович>

## Результат проверки

Вариант задания:

 - [x] стандартный, без NLP (на 3)
 - [ ] стандартный, с NLP (на 3-4)
 - [ ] продвинутый (на 3-5)
 
| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> 

## Введение

В результате выполнения курсового проекта, надеюсь улучшить своё понимание логического программирования и познакомиться с новым для меня типом представления данных.

## Задание

1. Скачать файл родословной европейской знати в формате GEDCOM. Изучить файл. 
2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: с использованием предикатов `father(отец, потомок)` и `mother(мать, потомок)`.   
3. Реализовать предикат проверки/поиска троюродного брата/сестры.
4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве

## Получение родословного дерева

Для получения родословного дерева в формате GEDCOM скачал предложенный файл родословной европейской знати, конвертировал (файл families.pl) и выбрал из него родословную киевских князей (файл kyivfamilies.pl). Получилось дерево более чем на 700 персон. В файле families.pl персон намного больше.

## Конвертация родословного дерева

Для решения задачи я использовал python, так как он хорошо подходит для таких задач из-за своей простоты и возможности быстро написать код.
Получилось две программы, основная и вспомогательная, сначала опишу основную:
1. Читаем строки с метками NAME, FAMS, FAMC, SEX (FAMS - семья родителей, FAMC - семья самой персоны). Сразу обрабатываем строки с именами и удаляем лишнее: уровни в начале каждой строки и некоторые знаки.
```python
    for line in gedFile:
    for each in ["NAME", "FAMS", "FAMC", "SEX"]:
        if each in line:
            newline = line.split(' ')[1:]
            newline[-1] = newline[-1].replace("\n", "")
            if newline[0] == "NAME":
              newline[1] = " ".join(newline[1:]).replace("/", "").replace("'", "")
              del newline[2:]
            result.append(newline)
    gedFile.close()
```
2. Собираем родителей и детей в один список семей.
3. Записываем в новый файл в нужном отсортированном формате.
```python
    for family in families:
    if len(family[2]) == 0:
        continue
    for child in family[2]:
        for parent in family[1]:
            if parent[1] == "M":
                facts.append("father(\'" + parent[0] + "\', \'" + child[0] + "\').\n")
            else:
                facts.append("mother(\'" + parent[0] + "\', \'" + child[0] + "\').\n")
    facts.sort(key=lambda st: st[0])
    for i in facts:
        output.write(i)
```

Результат находится в файле `families.pl`.

И небольшая программа для того чтобы из этого огромного списка отсортировать нужную родословную, результат в `kyivfamilies.pl`.
```python
    text = ""
    with open("families.pl", "r") as file:
        for line in file:
            if "Киевск" in line:
                text += line
    with open("kyivfamilies.pl", "w") as file:
        file.write(text)
```

## Предикат поиска родственника

Троюродный брат - внук брата и/или сестры деда или бабушки; сын двоюродного дяди или тёти, двоюродный племянник родителя. С троюродной сестрой аналогично.  
Так же условие можно представить так: какие-то из родителей людей X и Y являются двоюродным братьями/сёстрами, я реализовал это так:
```prolog
second_cousin(X, Y):-
	father(A, Y),
	father(B, X),
	cousin(A, B).
second_cousin(X, Y):-
	mother(A, Y),
	father(B, X),
	cousin(A, B).
second_cousin(X, Y):-
	father(A, Y),
	mother(B, X),
	cousin(A, B).
second_cousin(X, Y):-
	mother(A, Y),
	mother(B, X),
	cousin(A, B).
```
Все остальные предикаты в файле `task_3.pl`.

Примеры работы на простых данных:
```
?- second_cousin('Antosha', 'Dimas').
true.

?- second_cousin('Antosha', 'Antosha').
false.

?- second_cousin('Antosha', Y).
Y = 'Dimas'.
```

## Определение степени родства

Добавил к предикатам из `task_3.pl` несколько простых предикатов поиска для близких степеней родства.
`dist_relative` сначала рассматривает простые случаи.

```prolog
dist_relative('father', X, Y):- father(X, Y).
dist_relative('mother', X, Y):- mother(X, Y).
dist_relative('brother', X, Y):- brother(X, Y).
dist_relative('sister', X, Y):- sister(X, Y).
%и т.д.
```

Затем начинается поиск в глубину для определения более дальних степеней родства.  
Находятся все пути и переводятся в список отношений.

```prolog
dist_relative(W, X, Y):- 
	dfs(X, Y, W).

% перевод списка имён в список отношений
translator([X, Y], [R]):-
	dist_relative(R, X, Y).
translator([X, Y|T], [P, Q|R]):-
	dist_relative(P, X, Y),
	translator([Y|T], [Q|R]), !.
move(X, Y):-
	father(X, Y);
	mother(X, Y);
	brother(X, Y);
	sister(X, Y);
	son(X, Y);
	daughter(X, Y);
	husband(X, Y);
	wife(X, Y),
	grandfather(X, Y),
	grandmother(X, Y),
	grandson(X, Y),
	granddaughter(X, Y),
	aunt(X, Y),
	uncle(X, Y),
	cousin(X, Y),
	second_cousin(X, Y).
prolong([X|T], [Y, X|T]):-
	move(X, Y),
	not(member(Y, [X|T])).
path1([X|T], X, [X|T]).
path1(L, Y, R):-
	prolong(L, T),
	path1(T, Y, R).
dfs(X, Y, R2):-
	path1([X], Y, R1),
	translator(R1, R2).
```

Пример работы:
```

```


## Естественно-языковый интерфейс

## Выводы

Сформулируйте *содержательные* выводы по курсовому проекту в целом. Чему он вас научила? 
Над чем заставила задуматься? Помните, что несодержательные выводы -
самая частая причина снижения оценки.
